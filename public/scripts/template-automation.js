// Template Automation Component
// Handles automated task/project creation and field population

class TemplateAutomation {
  constructor(config = TEMPLATE_CONFIG, validator = new TemplateValidator()) {
    this.config = config;
    this.validator = validator;
    this.nextTaskId = 1;
  }

  // Generate next available task ID
  generateTaskId(existingTasks = []) {
    if (!this.config.AUTOMATION.AUTO_GENERATE_IDS) {
      return null;
    }

    const existingIds = existingTasks
      .map(task => task.task_id)
      .filter(id => id && typeof id === 'number')
      .sort((a, b) => a - b);

    // Find the first gap or use next number
    for (let i = 1; i <= existingIds.length + 1; i++) {
      if (!existingIds.includes(i)) {
        return i;
      }
    }

    return existingIds.length + 1;
  }

  // Auto-populate task fields
  autoPopulateTask(task, template = null, creatorId = null) {
    const populated = { ...task };

    // Generate ID if not provided
    if (!populated.task_id) {
      populated.task_id = this.generateTaskId(template ? template.tasks : []);
    }

    // Set defaults
    Object.keys(this.config.DEFAULTS.TASK).forEach(field => {
      if (populated[field] === undefined) {
        populated[field] = this.config.DEFAULTS.TASK[field];
      }
    });

    // Auto-set creation metadata
    if (this.config.AUTOMATION.AUTO_SET_CREATED_DATE && !populated.created_date) {
      populated.created_date = new Date().toISOString();
    }

    if (this.config.AUTOMATION.AUTO_SET_CREATOR_ID && !populated.creator_id) {
      populated.creator_id = creatorId || this.config.AUTOMATION.DEFAULT_CREATOR_ID;
    }

    // Normalize status if enabled
    if (this.config.AUTOMATION.AUTO_NORMALIZE_STATUSES && populated.status) {
      const normalized = this.validator.normalizeStatus(populated.status);
      if (normalized && normalized !== populated.status) {
        populated.status = normalized;
      }
    }

    // Set completed_date if status is completed
    if (populated.status === 'Completed' && !populated.completed_date) {
      populated.completed_date = new Date().toISOString();
    }

    // Auto-set progress based on status
    if (populated.status === 'Completed' && populated.progress_percentage === 0) {
      populated.progress_percentage = 100;
    }

    return populated;
  }

  // Auto-populate project fields
  autoPopulateProject(project) {
    const populated = { ...project };

    // Set defaults
    Object.keys(this.config.DEFAULTS.PROJECT).forEach(field => {
      if (populated[field] === undefined) {
        populated[field] = this.config.DEFAULTS.PROJECT[field];
      }
    });

    // Normalize status if enabled
    if (this.config.AUTOMATION.AUTO_NORMALIZE_STATUSES && populated.status) {
      const normalized = this.validator.normalizeStatus(populated.status);
      if (normalized && normalized !== populated.status) {
        populated.status = normalized;
      }
    }

    return populated;
  }

  // Create task from template with smart defaults
  createTaskFromTemplate(templateTask, template, customizations = {}) {
    const baseTask = { ...templateTask };

    // Apply customizations
    Object.assign(baseTask, customizations);

    // Auto-populate
    return this.autoPopulateTask(baseTask, template);
  }

  // Generate task dependencies automatically based on dates
  autoGenerateDependencies(tasks) {
    const tasksWithDates = tasks.filter(task =>
      task.start_date && task.end_date && task.task_id
    ).sort((a, b) => new Date(a.start_date) - new Date(b.start_date));

    const dependencies = [];

    tasksWithDates.forEach((task, index) => {
      // Find tasks that should precede this one based on date overlap
      const predecessors = tasksWithDates.slice(0, index).filter(prevTask => {
        const prevEnd = new Date(prevTask.end_date);
        const currentStart = new Date(task.start_date);
        return prevEnd >= currentStart;
      });

      predecessors.forEach(pred => {
        if (!task.dependencies.some(dep => dep.predecessor_task_id === pred.task_id)) {
          dependencies.push({
            predecessor_task_id: pred.task_id,
            type: 'FS',
            lag_days: 0
          });
        }
      });

      if (dependencies.length > 0) {
        task.dependencies = task.dependencies || [];
        task.dependencies.push(...dependencies);
      }
    });

    return tasks;
  }

  // Suggest task assignments based on worker skills
  suggestAssignments(task, workers) {
    if (!task.tags || !Array.isArray(task.tags) || !workers) {
      return [];
    }

    const suggestions = workers
      .filter(worker => {
        if (!worker.skills || !Array.isArray(worker.skills)) return false;

        // Check if worker has skills matching task tags
        return task.tags.some(tag =>
          worker.skills.some(skill =>
            skill.toLowerCase().includes(tag.toLowerCase()) ||
            tag.toLowerCase().includes(skill.toLowerCase())
          )
        );
      })
      .map(worker => ({
        name: worker.name,
        email: worker.email,
        role: worker.role,
        match_score: this.calculateSkillMatch(task.tags, worker.skills)
      }))
      .sort((a, b) => b.match_score - a.match_score);

    return suggestions;
  }

  // Calculate skill match score
  calculateSkillMatch(taskTags, workerSkills) {
    if (!taskTags || !workerSkills) return 0;

    let matches = 0;
    taskTags.forEach(tag => {
      workerSkills.forEach(skill => {
        if (skill.toLowerCase().includes(tag.toLowerCase()) ||
            tag.toLowerCase().includes(skill.toLowerCase())) {
          matches++;
        }
      });
    });

    return matches / Math.max(taskTags.length, workerSkills.length);
  }

  // Auto-categorize task based on tags and description
  autoCategorize(task, categories) {
    if (!categories || !Array.isArray(categories)) return null;

    const text = `${task.task_name} ${task.description || ''} ${task.tags ? task.tags.join(' ') : ''}`.toLowerCase();

    // Simple keyword matching for categories
    const categoryKeywords = {
      'Project Setup': ['setup', 'planning', 'requirements', 'init'],
      'Backend Development': ['backend', 'api', 'database', 'server'],
      'Frontend Development': ['frontend', 'ui', 'react', 'interface'],
      'Deployment': ['deploy', 'ci-cd', 'devops', 'server']
    };

    for (const category of categories) {
      const keywords = categoryKeywords[category.name] || [];
      if (keywords.some(keyword => text.includes(keyword))) {
        return category.name;
      }
    }

    return null;
  }

  // Validate and fix common issues
  validateAndFix(task, template = null) {
    let fixedTask = { ...task };
    const issues = [];

    // Fix missing required fields with defaults
    this.config.REQUIRED_FIELDS.TASK.forEach(field => {
      if (!fixedTask[field]) {
        if (field === 'task_id') {
          fixedTask[field] = this.generateTaskId(template ? template.tasks : []);
          issues.push(`Auto-generated ${field}`);
        } else if (field === 'status') {
          fixedTask[field] = this.config.DEFAULTS.TASK.status;
          issues.push(`Set default ${field}`);
        } else if (field === 'priority') {
          fixedTask[field] = this.config.DEFAULTS.TASK.priority;
          issues.push(`Set default ${field}`);
        } else if (field === 'estimated_hours') {
          fixedTask[field] = 8; // Default 1 day
          issues.push(`Set default ${field} to 8`);
        } else {
          issues.push(`Missing required field: ${field}`);
        }
      }
    });

    // Fix date formats
    ['start_date', 'end_date'].forEach(field => {
      if (fixedTask[field] && !this.validator.isValidDate(fixedTask[field])) {
        try {
          // Try to parse and reformat
          const date = new Date(fixedTask[field]);
          if (!isNaN(date.getTime())) {
            fixedTask[field] = date.toISOString().split('T')[0];
            issues.push(`Reformatted ${field} to YYYY-MM-DD`);
          }
        } catch (e) {
          issues.push(`Invalid ${field} format`);
        }
      }
    });

    // Fix status normalization
    if (fixedTask.status && !this.config.ENUMS.TASK_STATUS.includes(fixedTask.status)) {
      const normalized = this.validator.normalizeStatus(fixedTask.status);
      if (normalized) {
        fixedTask.status = normalized;
        issues.push(`Normalized status to "${normalized}"`);
      }
    }

    return { task: fixedTask, issues };
  }

  // Generate project summary
  generateProjectSummary(template) {
    if (!template.tasks) return {};

    const summary = {
      total_tasks: template.tasks.length,
      tasks_by_status: {},
      tasks_by_priority: {},
      total_estimated_hours: 0,
      total_actual_hours: 0,
      critical_path_tasks: 0,
      tasks_with_dependencies: 0,
      assigned_tasks: 0
    };

    template.tasks.forEach(task => {
      // Count by status
      summary.tasks_by_status[task.status] = (summary.tasks_by_status[task.status] || 0) + 1;

      // Count by priority
      summary.tasks_by_priority[task.priority] = (summary.tasks_by_priority[task.priority] || 0) + 1;

      // Sum hours
      summary.total_estimated_hours += task.estimated_hours || 0;
      summary.total_actual_hours += task.actual_hours || 0;

      // Count special categories
      if (task.is_critical_path) summary.critical_path_tasks++;
      if (task.dependencies && task.dependencies.length > 0) summary.tasks_with_dependencies++;
      if (task.assigned_workers && task.assigned_workers.length > 0) summary.assigned_tasks++;
    });

    return summary;
  }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
  module.exports = TemplateAutomation;
}
